<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
 tex2jax: {
 inlineMath: [['$', '$'] ],
 displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
 }
 });
</script>

# 参考

https://www.youtube.com/watch?v=Y0A0RX-FDBw&t=6941s

# O(ビックオー)

- アルゴリズムの実行時間をざっくりと表す。傾向だけわかる。
- 実行時間の上限を表す。（最大でどれだけの時間がかかるのか）
- Ω は実行時間の下限を表す。（最小でどれだけの時間がかかるのか）
-

## Binary Search

- O(log n)になる

最初の配列の大きさが $1/2$ ずつ小さくなっていくため。
サーチ終了時には、最初の配列が何回か $1/2$ されている。

- Ω(1)になる

探している値が真ん中にある場合があるため。

リニアサーチよりもバイナリサーチの方が実行時間では優れているが、
小さいデータセットに対して、バイナリサーチのような複雑なアルゴリズムを適用する必要はない。
メモリなどのリソース、実行時間、実装時間などのトレードオフの評価が重要。

## なぜソートをするのか

バイナリーサーチをする際に、配列がソートされている必要があるため

## selection sort

要素が n 個あった場合、一番最初は n - 1 回比較をしている。2 回目は n-2 回、3 回目は n-3 回比較をしている。

これを式にすると
$$ n + (n-1) + (n-2) + (n-3) + ... + 1 $$
なんかの公式より
$$ n(n+1)/2 $$
これを分解して
$$ n^2/2 + n/2 $$
になる。

この時、n を膨大な数にしてみる（例えば、無限 ∞）。そうすると、この式で支配的になるのは $ n^2 $ になる。(無限を 2 で割ったところで無限、$ ∞ $より$ ∞^2 $の方が圧倒的にでかい)

だから、セレクトソートの実行時間は
$$ O(n^2) $$
で表すことができる。

$ Ω $を考える際は、ソートされている状態に対してアルゴリズムを適用したらどうなるか考える。（最高のケースはソートされている場合で、最低の場合は、逆にソートされている場合。）

セレクトソートは、ソートされている状態でもソートされていない時と同じように比較を行うため
$$ Ω(n^2) $$
になる。

## bubble-sort

n-1 回のループの中で n-1 回ループをしてるため、式にすると
$$ (n-1)(n-1) $$
分解して
$$ n^2 -2n + 1 $$
になる。

n を大きな数にした場合、この式で支配的になるのは $ n^2 $。

だから、バブルソートの実行時間は
$$ Ω(n^2) $$
になる。

バブルソートは、ソートされている状態でアルゴリズを適用すると (n-1) × 1 回の比較をして、ソートされていることを確認する。

そのため
$$ Ω(n) $$
になる。

## merge-sort

https://youtu.be/Y0A0RX-FDBw?t=6947
